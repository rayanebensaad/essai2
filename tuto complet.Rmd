---
title: "R Notebook"
output: github_document
---

```{r}
library(dada2)
```

```{r}
install.packages("Rcpp")
```
```{r}
library(dada2)
packageVersion("dada2")
```
```{r}
path<- "/home/rstudio/essai2/MiSeq_SOP"
list.files(path)
```
```{r}
fnFs <- sort(list.files(path, pattern="_R1_001.fastq", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_R2_001.fastq", full.names = TRUE))
print(fnFs)
print(fnRs)
```
```{r}
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)
print(sample.names)
```

```{r}
plotQualityProfile(fnFs[1:20])
plotQualityProfile(fnRs[1:20])

```
```{r}
filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names
print(filtFs)
print(filtRs)

```
```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE)
print(out)
head(out)

```
```{r}
errF <- learnErrors(filtFs, multithread=TRUE)

```
```{r}
errR <- learnErrors(filtRs, multithread=TRUE)
```
```{r}
plotErrors(errF, nominalQ=TRUE)
```

```{r}
dadaFs <- dada(filtFs, err=errF, multithread=TRUE)
```
```{r}
dadaRs <- dada(filtRs, err=errR, multithread=TRUE)
```
```{r}
dadaFs[[3]]

#les reads sont les seq brutes qui ont ete generes a partir de l'echantillon
#les seq uniques sont les seq semi brutes qui ont ete trouve apres l'elimination des seq repetes et les seq qui n'ont pas vraiement de sens?comme par ex les seq qui contiennent des N
#les variants sont les seq fournies par dada2 apres la correction des seq qui ont ete pas bien sequencé donc apres elimination des erreurs de sequecage

```
```{r}
mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
#cette instruction et pour merger les sequences R1 et R2 pour obtenir les sequences finales completes
head(mergers[[3]])
```
```{r}
seqtab <- makeSequenceTable(mergers)
dim(seqtab)
#pourquoi ca donne 293 seq uniques?
```
```{r}
table(nchar(getSequences(seqtab))) #cette instru nous donne les diff longeurs des seq et combien de seq ont une longeur specifique
#1e seq est de longeur de 251
# 88 ont une longuer de 252 
#196 ont une longeur de 253
```
```{r}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)  #pour eliminer les chimere
#les chimere sont les seq qui ont ete merger incorrectement
dim(seqtab.nochim)
#print(seqtab.nochim)
```
```{r}
sum(seqtab.nochim)/sum(seqtab)
```
```{r}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names
head(track)

#ce tableau montre l'abondance totale des seq unique genre les seq uniques qui sont bien et qui sont repetees
#selon chatgpt Abondance totale vs. séquences uniques : La table track montre les nombres totaux de séquences (ou d’abondances de séquences) à chaque étape. En revanche, lorsque vous exécutez nchar(getSequences(seqtab)), cela vous donne des informations sur les séquences uniques (par leur longueur), mais ne reflète pas directement l'abondance totale de chaque séquence dans les échantillons
```
```{r}
taxa <- assignTaxonomy(seqtab.nochim, "/home/rstudio/essai2/silva_nr_v132_train_set.fa.gz?download=1", multithread=TRUE)

#Cette fonction de DADA2 permet d'assigner une classification taxonomique à chaque séquence dans le tableau de séquences (ici seqtab.nochim), après suppression des séquences chimériques. Elle utilise une base de données de référence pour faire correspondre chaque séquence aux catégories taxonomiques telles que le domaine, le phylum, la classe, l'ordre, la famille, et le genre (voire l'espèce si disponible).
#multithread=TRUE : Permet d'effectuer l'assignation taxonomique en parallèle (sur plusieurs cœurs du processeur), ce qui accélère le processus.
```

```{r}
taxa.print <- taxa # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)
```
```{r}
unqs.mock <- seqtab.nochim["Mock",]
unqs.mock <- sort(unqs.mock[unqs.mock>0], decreasing=TRUE) # Drop ASVs absent in the Mock
cat("DADA2 inferred", length(unqs.mock), "sample sequences present in the Mock community.\n")

#Mock" fait référence à un échantillon témoin ou contrôle, souvent utilisé pour valider la précision de l'analyse. Un "Mock community" est une communauté microbienne artificiellement composée de plusieurs espèces dont la composition est connue.
#La sortie unqs.mock est un vecteur qui contient le nombre d'abondances de chaque séquence (ASV, Amplicon Sequence Variant) dans l'échantillon Mock.
#unqs.mock[unqs.mock > 0] : Ce filtre sélectionne uniquement les séquences présentes dans le Mock (c'est-à-dire les séquences avec une abondance supérieure à 0). Cela signifie que les séquences absentes du Mock community sont exclues.

#sort(..., decreasing = TRUE) : Trie les séquences sélectionnées par ordre décroissant d'abondance. Cela permet de voir les séquences les plus abondantes en premier.
```
```{r}
mock.ref <- getSequences(file.path(path, "HMP_MOCK.v35.fasta"))
match.ref <- sum(sapply(names(unqs.mock), function(x) any(grepl(x, mock.ref))))
cat("Of those,", sum(match.ref), "were exact matches to the expected reference sequences.\n")

#getSequences() : Cette fonction extrait les séquences nucléotidiques d'un fichier FASTA.

#file.path(path, "HMP_MOCK.v35.fasta") : Spécifie le chemin du fichier FASTA contenant les séquences de référence du Mock community, ici appelé "HMP_MOCK.v35.fasta". Le fichier FASTA contient les séquences que vous attendez dans l'échantillon Mock.

#mock.ref : Ce vecteur contiendra toutes les séquences de référence du Mock community, qui seront ensuite comparées aux séquences trouvées par DADA2

```
```{r}
library(phyloseq); packageVersion("phyloseq")

```
```{r}
library(Biostrings); packageVersion("Biostrings")
```
```{r}
library(ggplot2); packageVersion("ggplot2")
```
```{r}
theme_set(theme_bw())
```

```{r}
samples.out <- rownames(seqtab.nochim)
subject <- sapply(strsplit(samples.out, "D"), `[`, 1)
gender <- substr(subject,1,1)
subject <- substr(subject,2,999)
day <- as.integer(sapply(strsplit(samples.out, "D"), `[`, 2))
samdf <- data.frame(Subject=subject, Gender=gender, Day=day)
samdf$When <- "Early"
samdf$When[samdf$Day>100] <- "Late"
rownames(samdf) <- samples.out
print(samdf)
```

```{r}
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa))
ps <- prune_samples(sample_names(ps) != "Mock", ps)  #Cela signifie que toutes les informations relatives à l'échantillon Mock (qui est souvent utilisé pour le contrôle de qualité) seront exclues de l'analyse.
```

```{r}
dna <- Biostrings::DNAStringSet(taxa_names(ps))
names(dna) <- taxa_names(ps)
ps <- merge_phyloseq(ps, dna)
taxa_names(ps) <- paste0("ASV", seq(ntaxa(ps)))
ps
```
```{r}
plot_richness(ps, x="Day", measures=c("Shannon", "Simpson"), color="When")
```

```{r}
ps.prop <- transform_sample_counts(ps, function(otu) otu/sum(otu))
ord.nmds.bray <- ordinate(ps.prop, method="NMDS", distance="bray")
```
```{r}
plot_ordination(ps.prop, ord.nmds.bray, color="When", title="Bray NMDS")
```




```{r}
top20 <- names(sort(taxa_sums(ps), decreasing=TRUE))[1:20]
ps.top20 <- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top20 <- prune_taxa(top20, ps.top20)
plot_bar(ps.top20, x="Day", fill="Family") + facet_wrap(~When, scales="free_x")
```


